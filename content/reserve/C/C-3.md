+++
title= "C语言笔记-3：函数与递归"
description = ""
summary = ""
toc = true
authors = [ "zhang"]
tags = ["C", "笔记"]
categories = []
series = ["C"]
date= "2021-02-07"
lastmod = "2021-02-07"
draft = false

+++

C语言笔记-3：函数与递归
<!--more-->

# 函数与递归

## 函数的定义

> 子程序

### 分类

1. 库函数
2. 自定义函数

### 库函数

如同Python的库，轮子

C Library中的一些函数

+ IO函数（输入输出函数）
+ 字符串操作函数
+ 字符操作函数
+ 内存操作函数
+ 时间/日期函数
+ 数学函数
+ 其他库函数

使用库函数，必须引用相应的头文件<xxx.h>



### 自定义函数

#### 构成

和库函数一样，有函数名、返回值类型、函数参数

```c
ret_type fun_name(para1, *)
{
    statement;语句项
}
/*ret_type - 返回类型
  fun_name - 函数名
  para1 - 函数参数
*/
```

## 函数的参数

### 形式参数

> 函数名后的变量
>
> 形参，当函数调用完后会被销毁
> 只在函数中有效

### 实际参数

> 真实传递给函数的参数
>
> 实参可以是：常量、变量、表达式、函数等
> 它是实际的量，有确定的值

当实参传给形参时，形参其实是实参的一份***临时拷贝***。对形参的改变是不会影响实参的。

## 函数的调用

当需要对变量进行直接操作时，往往考虑传址调用。

### 传值调用

> 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参

```c
#include<stdio.h>

void Swap1(int x, int y)//形参
{
    int tmp = x;
    x = y;
    y = tmp;
}
//以上的x，y有自己的空间
int main()
{
    int a = 10;
    int b = 20;
    printf("a=%d,b=%d\n",a,b);//10，20
    Swap1(a,b);//实参
    printf("a=%d,b=%d\n",a,b);//10,20
    return 0;
}
```

### 传址调用

> 将外部变量的地址传入函数，建立真正的联系

```c
#include<stdio.h>

void Swap2(int* pa, int* pb)
{
    int tmp = *pa;
    *pa = *pb;
    *pb = tmp;
}

int main()
{
    int a = 10;
    int b = 20;
    printf("a=%d,b=%d\n",a,b);//10,20
    Swap2(&a,&b);
    printf("a=%d,b=%d\n",a,b);//20,10
    return 0;
}
```

## 函数：传入的数组？

实现二分查找

```c 
#include<stdio.h>

int binsry_search(int arr[], int k)
{
    int sz = sizeof(arr)/sizeof(arr[0]);//error
    int left = 0;
    int right = sz-1;
    
    while (left<=right)
    {
        int mid = (left+right)/2;
        if (arr[mid]<k)
            left = mid+1;
        else if (arr[mid]>k)
            right = mid-1;
        else
            return mid;
    }
    return -1;
}

int main()
{
    int arr[] = {1,2,3,4,5,6,7,8,9,10};
    int k = 7;
    int ret = binary_search(arr,k);
    if (-ret)
        printf("找不到指定的数字\n");
    else
        printf("找到了，下标是：%d\n",ret);
    return 0;
}
```

第五行`int sz = sizeof(arr)/sizeof(arr[0]);` 对于传入函数的数组，实际传入的只是***数组第一个元素的地址***。因此**不能**求得元素个数。

拿到外面计算

```c
#include<stdio.h>

int binary_search(int arr[], int k, int sz)
{
    int left = 0;
    int right = sz-1;
    
    while (left<=right)//= - 同时等于
    {
        int mid = (left+right)/2;//中间元素的下标
        if (arr[mid] < k)
            left = mid+1;
        else if (arr[mid] > k)
            right = mid-1;
        else
            return mid;
    }
    return -1;
}

int main()
{
    int arr[] = {1,2,3,4,5,6,7,8,9,10};
    int k = 7;
    int sz = sizeof(arr)/sizeof(arr[0]);
    int ret = binary_search(arr,k,sz);
    if (ret == -1)
        printf("找不到指定的数字\n");
    else
        printf("找到了，下标是：%d\n",ret);
    return 0;
}
```

## 函数的嵌套调用和链式访问

函数之间的有机结合

### 嵌套调用

在函数中调用另一个函数

### 链式访问

> 把一个函数的返回值作为另外一个函数的参数

```c
#include<stdio.h>

int main()
{
    printf("%d\n",printf("%d\n",printf("%d\n",43)));
    return 0;
}
//4321
```

`printf()`的返回值是打印的字符的个数。

## 函数的声明和定义

```c
//函数声明
int Add(int, int);//也可以加上变量名

//主函数
int main()
{
    int a = 10;
    int b = 20;
    //函数调用
    int sum = Add(a, b);
    printf("%d",sum);
}

//函数的定义
int Add(int x, int y)
{
    int z = x+y;
    returnn z;
}
```

函数声明在使用之前
函数在主函数前就不用声明

函数声明在`.h`文件中
函数定义在`.c`文件中
和在一块儿叫**模块**

然后引用头文件就行了：`#include "xxx.h"`

用双引号

`.h`文件：

```c
#ifndef _ADD_H_//如果未定义
#define _ADD_H_

//函数声明
int Add(int, int);

#endif

```

## 函数递归

### 什么是递归

> 函数调用自身的方法（recursion）
> （大事化小）

### 递归的两个必要条件

+ 存在限制条件，即**边界条件**，满足时则不继续
+ 每次递归则越来越接近边界条件，即**收敛**



>  无休止的调用会造成Stack overflow：栈溢出
>                                     ![Stack][Stack]

eg1: 打印数字

```c
void print_num(int n)
{
    if (n>9)               //递归边界
        print_num(n/10);   //递归
    printf("%d ",n%10);
}
```

eg2:字符串长度（无临时变量）

```c
//有临时变量
int my_strlen_1(char* str)
{
    int count = 0;
    while (*str != '\0')
    {
        count++;   //计数器加一
        str++;     //指针向后移动
    }
    return count;
}

//无临时变量
int my_strlen_2(char* str)
{
    if (*str != '\0')//边界条件
        return 1+mystrlen_2(str+1);//函数递归
    else
        return 0;
}
```



> TDD - 测试驱动开发
> 先设计函数在主函数中的实际使用，然后再去实现函数。

### 递归与迭代

> 递归与循环算法是殊途同归的
>
> 而递归有时会有大量的重复计算

eg：

求解第n个斐波那契数（不考虑溢出）

```c
//递归算法 - 大量重复计算
int Fib1(int n)
{
    if (n<=2)
        return 1;
    else
        return Fib(n-1) + Fib(n-2);//无法计算较大的n
}

//循环算法 - 计算迅速
int Fib2(int n)
{
    int a=1,b=1,c=1;
    while (n>2)
    {
        c = a + b;
        a = b;
        b = c;
        n--;
    }
    return c;
}
```



### 递归深度

> 递归函数f，第一次进去认为是深度是1。以后从深度为n的f中再调用用f(直接或者间接)，这个被调用f的深度为n+1; 整个f最大的深度为***递归深度***。



































[Stack]:data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIyMTFweCIgaGVpZ2h0PSIzNDFweCIgdmlld0JveD0iLTAuNSAtMC41IDIxMSAzNDEiIGNvbnRlbnQ9IiZsdDtteGZpbGUgaG9zdD0mcXVvdDtFbGVjdHJvbiZxdW90OyBtb2RpZmllZD0mcXVvdDsyMDIxLTAyLTIxVDAyOjMxOjM2LjQ5N1omcXVvdDsgYWdlbnQ9JnF1b3Q7NS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIGRyYXcuaW8vMTMuOS45IENocm9tZS84NS4wLjQxODMuMTIxIEVsZWN0cm9uLzEwLjEuNSBTYWZhcmkvNTM3LjM2JnF1b3Q7IGV0YWc9JnF1b3Q7bEgyWC1POHBiRlhQYmUtTnVYZV8mcXVvdDsgdmVyc2lvbj0mcXVvdDsxMy45LjkmcXVvdDsgdHlwZT0mcXVvdDtkZXZpY2UmcXVvdDsmZ3Q7Jmx0O2RpYWdyYW0gaWQ9JnF1b3Q7QzVSQnM0M29EYS1LZHpaZU50dXkmcXVvdDsgbmFtZT0mcXVvdDtQYWdlLTEmcXVvdDsmZ3Q7N1pqUmJwc3dGSWFmeHBlVkFNZGdMb0dRdGx1emFXcTNYSHZnQXF2Qm1lTXNTWjkrTnBna0JLU3FreUtVcFRlUitXMGY0UC9Pc1IwQWpNcnRyU0RMZk01VHlvQmpwVnNBcDhCeElMYlVyeFoyallBODFBaVpLTkpHc2cvQ1kvRktqV2ptWmVzaXBhdk9RTWs1azhXeUt5YThxbWdpT3hvUmdtKzZ3NTQ1Njk1MVNUTGFFeDRUd3ZycW9raGwzcWpZOFE3NkhTMnl2TDJ6N2ZwTlQwbmF3U2JFS2ljcDN6UlMvWEl3QmpBU25NdW1WVzRqeXJSM3JTK0wrOTJDUGJ5NHQ1KytyWDZUNytIbnB5OC9iaHBiWnUrWnNuOEZRU3Y1ejZIdjBldFR0TnNtK2QxTmlmalgrYSs1OWRDRy9rUFkydmhsM2xYdVdnTUZYMWNwMVVFc0FNTk5Ya2o2dUNTSjd0Mm9qRkZhTGt1bXJtelZOT0dva0hSNzR2OGJEMi92SFZXWlNIbEpwZGlwZVNhSzA2YWh5Y0wyY25OQWFpT2o1VWM0WVp1R3hLUlJ0Zzk5c0VvMWpGdnZjTTY1Rk9kODFISE9IM0RPR1hBT244czRlS0hHamUvYzVFS2RzMGQzRHZXZGl4SEFMc0JJTjRJcDhISFBTK1dLN0JxMmtvSy8wSWd6THBSUzhVcU5ESjhMeGs0a3dvcXNVcGVKY3BFcVBkUWVGMnBQQ2t4SFdhU3B2czBnb1M3RGMwR0NzQXNKOVJsTkJoQTU1MExrRGlCeVFXQUJqR3RXRVFpREswTTBRZDFOYjE4ell6SHlCc3RJTTNJL0dCbnZ4MmFFQnhqNXdGY3JuSzhMU2kyeDJQNkFaZGJBc1dINWd3VVYyaHFUb29ZaENKclZiNlkzS0sxNHV1MjRURlA2S1ZRcjA2MTZqQWZDcVVhc2R0L1FxdU5NUWVDWTZiaC9WdmkvV2U5UC91M2lhZlZaK3dPczNYT3hicC9uOUJBUzFJeVBLak9NYXZ3WWhESHdaeUQyZ0I4QVBCazZzWnptUVVrWTQwbGZUNHgrMVJuZ2pKNEJBLysyTlZSa3F0elUvZHZsdnBKRW1RM2lDUWhuSUlqMXlLQXArdU5jT1FseTFlemgrZGlyeThNM29McnY2RU1halA4QyZsdDsvZGlhZ3JhbSZndDsmbHQ7L214ZmlsZSZndDsiPjxkZWZzLz48Zz48cmVjdCB4PSIwIiB5PSIzMCIgd2lkdGg9IjE1MCIgaGVpZ2h0PSIzMTAiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxyZWN0IHg9IjE1IiB5PSI0MCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSI4MCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iMTUiIHk9IjI0MCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSI4MCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iMTUiIHk9IjE0MCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSI4MCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iNTUiIHk9IjAiIHdpZHRoPSI0MCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7IiBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDM4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTBweDsgbWFyZ2luLWxlZnQ6IDU2cHg7Ij48ZGl2IHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDA7IHRleHQtYWxpZ246IGNlbnRlcjsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6ICMwMDAwMDA7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IHdvcmQtd3JhcDogbm9ybWFsOyAiPuWGheWtmDwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI3NSIgeT0iMTQiIGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+5YaF5a2YPC90ZXh0Pjwvc3dpdGNoPjwvZz48cmVjdCB4PSIxNzAiIHk9IjcwIiB3aWR0aD0iNDAiIGhlaWdodD0iMjAiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAzOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDgwcHg7IG1hcmdpbi1sZWZ0OiAxNzFweDsiPjxkaXYgc3R5bGU9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMDsgdGV4dC1hbGlnbjogY2VudGVyOyAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAxMnB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogIzAwMDAwMDsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgd29yZC13cmFwOiBub3JtYWw7ICI+5qCI5Yy6PC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjE5MCIgeT0iODQiIGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+5qCI5Yy6PC90ZXh0Pjwvc3dpdGNoPjwvZz48cmVjdCB4PSIxNzAiIHk9IjE3MCIgd2lkdGg9IjQwIiBoZWlnaHQ9IjIwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiIHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMzhweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAxODBweDsgbWFyZ2luLWxlZnQ6IDE3MXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7ICI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiAjMDAwMDAwOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyB3b3JkLXdyYXA6IG5vcm1hbDsgIj7loIbljLo8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMTkwIiB5PSIxODQiIGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+5aCG5Yy6PC90ZXh0Pjwvc3dpdGNoPjwvZz48cmVjdCB4PSIxNzAiIHk9IjI3MCIgd2lkdGg9IjQwIiBoZWlnaHQ9IjIwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiIHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMzhweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAyODBweDsgbWFyZ2luLWxlZnQ6IDE3MXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7ICI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiAjMDAwMDAwOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyB3b3JkLXdyYXA6IG5vcm1hbDsgIj7pnZnmgIHljLo8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMTkwIiB5PSIyODQiIGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+6Z2Z5oCB5Yy6PC90ZXh0Pjwvc3dpdGNoPjwvZz48cmVjdCB4PSIzMCIgeT0iNTAiIHdpZHRoPSI5MCIgaGVpZ2h0PSI2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7IiBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDg4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogODBweDsgbWFyZ2luLWxlZnQ6IDMxcHg7Ij48ZGl2IHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDA7IHRleHQtYWxpZ246IGNlbnRlcjsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6ICMwMDAwMDA7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IHdvcmQtd3JhcDogbm9ybWFsOyAiPuWxgOmDqOWPmOmHjzxiciAvPuWHveaVsOW9ouWPgjwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI3NSIgeT0iODQiIGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+5bGA6YOo5Y+Y6YePJiN4YTvlh73mlbDlvaLlj4I8L3RleHQ+PC9zd2l0Y2g+PC9nPjxyZWN0IHg9IjMwIiB5PSIxNTAiIHdpZHRoPSI5MCIgaGVpZ2h0PSI2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7IiBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDg4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTgwcHg7IG1hcmdpbi1sZWZ0OiAzMXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7ICI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiAjMDAwMDAwOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyB3b3JkLXdyYXA6IG5vcm1hbDsgIj7liqjmgIHlvIDovp/nmoTlhoXlrZg8YnIgLz5tYWxsb2M8YnIgLz5jYWxsb2M8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNzUiIHk9IjE4NCIgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMnB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj7liqjmgIHlvIDovp/nmoTlhoXlrZhtYWxsb2MuLi48L3RleHQ+PC9zd2l0Y2g+PC9nPjxyZWN0IHg9IjMwIiB5PSIyNTAiIHdpZHRoPSI5MCIgaGVpZ2h0PSI2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7IiBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDg4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMjgwcHg7IG1hcmdpbi1sZWZ0OiAzMXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7ICI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiAjMDAwMDAwOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyB3b3JkLXdyYXA6IG5vcm1hbDsgIj7lhajlsYDlj5jph488YnIgLz5zdGF0aWPkv67ppbDnmoTlj5jph488L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNzUiIHk9IjI4NCIgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMnB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj7lhajlsYDlj5jph48mI3hhO3N0YXRpY+S/rumlsOeahOWPmOmHjzwvdGV4dD48L3N3aXRjaD48L2c+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDQyNDg3IiB0YXJnZXQ9Il9ibGFuayI+PHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMHB4IiB4PSI1MCUiIHk9IjEwMCUiPlZpZXdlciBkb2VzIG5vdCBzdXBwb3J0IGZ1bGwgU1ZHIDEuMTwvdGV4dD48L2E+PC9zd2l0Y2g+PC9zdmc+